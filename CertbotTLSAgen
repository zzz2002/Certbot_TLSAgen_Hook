#!/bin/bash
# -*- mode: sh; -*-
# Copyright (c) 2017 John L. Allen
# This program is free software: you can redistribute it and/or modify it under the terms of the 
# GNU General Public License as published by the Free Software Foundation, either version 3 of 
# the License, or (at your option) any later version.
# This program is distributed in the hope that it will be useful, but WITHOUT ANY WARRANTY; 
# without even the implied warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  
# *See the GNU General Public License for more details. You should have received a copy of the 
# GNU General Public License along with this program.  If not, see <http://www.gnu.org/licenses/>.
#
#Last modified:
#	2017-04-02
#	2017-04-07
#	2017-04-07 20:30
#=============
if [[ "${SHELL##*/}" != 'bash' || "${BASH_VERSINFO[0]:0:1}" -lt 4 ]]; then
    echo "error: script must run in bash version 4.0 or later"
    false
    exit
fi
shopt -s extglob   										# <--- start using bash features right after version check

startTime=10#$(date +%N)

pr=
nr=
 
installPath="/root"										# where we are installed/stored
updateAction="manual"										# what DNS update process(?) to use

												#** variables derived either from the command line parameters 
												#   or from the renew-hook environment variables
certbotLineage=""										# path to the certbot generated cert ...(RENEWED_LINEAGE or $1)
declare -a certbotDomains 									# array into which RENEWED_DOMAINS or $2 Domains are split

declare -a services=( smtp smtps submission imap sieve dav davical https )			# array of servics we want TLSA records for
declare -A pseudoSRVrecords									# associative array to be used when SRV records are not available

TLSA_Record=y
TLSA_Usage=dane-ee										# TLSA usage 
TLSA_Selector=pkey										# TLSA selector 
TLSA_Type=sha-256										# TLSA type

TLSA_TTL=1800											# TLSA DNS record TTL in seconds 
TLSA_RemoveDelay=2700										# the interval in seconds between adding new TLSA records and removing the old ones.
TLSA_AutoRemove=no

outputFilepath="/etc/bind/tlsa/example.com"							# where do you want to put the TLSA records, default values
outputFilenameBase="tlsa"									# base filename for the TLSA records - generated  as base_filename.sequence_number

logOnly=no											# temp work around sysout + syslog
logFile="/var/log/A_tlsagen.log"								# logfile name & path

declare -a outputFilenames									# array containing the file names for old and the new TLSA records 

declare -A messageText										# associative array containing information &  error messages

setupSystem() {
    logOnly="${logOnly,,}"
    TLSA_AutoRemove="${TLSA_AutoRemove,,}"

    updateAction="${updateAction,,}"
    TLSA_Usage="${TLSA_Usage,,}"
    TLSA_Selector="${TLSA_Selector,,}"
    TLSA_Type="${TLSA_Type,,}"
    
    exec 3>> "$logFile"
}

outputMessage() {
    local errorCode												# local version of the error code
    local msgVars												# number of vaiables a message expects 
    local extraData												# additional data 
    local badCode												# variable to save additional data 
    local xitCode												# just what it says it is
    errorCode=${1^^}												# set the internal variable to the upper case $1
    [[ -z "$errorCode" || -z "${messageText[$errorCode]}" ]] && { badCode="$errorCode"; errorCode='E999'; }	# did we get passed an error code and do we have a message for it
														# no, set the oops code and save trhe actual code for diags 
    msgVars=$(( 10#${messageText[$errorCode]:0:1} ))								# yes,get the number of variables needed for this message
    extraData="${*:$(( msgVars + 2 ))}"										# save the extra data in a variable, stops the msg repeat
    extraData="${extraData%%\ *}"										# 
    [[ -n "$extraData" || -n "$badCode" ]] && extraData=' ** '"$badCode $extraData"				# add the seperator to front of this data
    printf -- "%s %s - %s ${messageText[$errorCode]:2} %s\n" "$(date "+%Y-%m-%d %H:%M:%S.%6N")" "${0##*/}" "$errorCode" "${@:2:$msgVars}" "$extraData" >&3
    [[ "$logOnly" = @($nr) ]] && printf  "%s - %s ${messageText[$errorCode]:2}  \n" "${0##*/}" "$errorCode" ${@:2:$msgVars} 2>&1

    case ${errorCode:0:1} in
	I|W) xitCode=0;;											# for info and warning messages return 0
	E|F) xitCode=1;;											# for error or fatal return 1
	*)   xitCode=3;;												# ooops, don't know what this means, exit 3
    esac
    return $xitCode
}

loadMessages() {
    local aline
    local i
    local j
    while read -r aline; do
	    if [[ -n $aline ]]; then
		j="${aline:0:1}"
		aline="${aline%%\:\#\ \ *}"
		case "${j^^}" in
		    I|W|E|F)
			i="${aline:0:4}"
			messageText[${i^^}]=${aline:5}
			;;
		    R)
			[[ "${aline:1:1}" = '+' ]] && { pr="${aline:7}"; pr="${pr// /}"; }
			[[ "${aline:1:1}" = '-' ]] && { nr="${aline:7}"; nr="${pr// /}"; }
			;;  
		    *)
		        #  any thing else is ignored for the moment
		    ;;
		esac
	    fi
    done < "$installPath"/CertbotTLSAgen."$1".msgs
}

setLineage() {
	certbotLineage=$RENEWED_LINEAGE								# Check if either the Certbot environment variables or the command line 
	[[ ! -z $1 ]] && certbotLineage=$1							# parameters have been set, this may/will depend on how this script is invoked.
	if [[ -z $certbotLineage ]]; then 							# N.B. The Command line parameter overides the environment variable 
	    outputMessage e001;  return $?							# should they both be present
	elif [[ ! -d $certbotLineage ]]; then
	    outputMessage e002; return $?
	fi
}

setDomains() {
	certbotDomains=( $RENEWED_DOMAINS )							# Has $2 or the environment variable RENEWED_DOMAINS been set. If more than 
	[[ ! -z $1 ]] && certbotDomains=( $1 ) 							# one domain is specified they are expected to be in the form of a space 
	if [[ ${#certbotDomains[@]} -le 0 ]]; then 						# seperated list.
	    outputMessage e003; return $?
	fi
}

#	Check the outputFilepath - the location (directory) where files containing the generated TLSA records will be 
#	placed exists, if not mkdir. Check that the TLSA filename base has been set. The filename base is used to generate
#	filenames in the form of base.sequence

setOutputFilenames() {
    local oldName
    local newName
    local fileCount

    if [ ! -d "$1" ]; then 									# Does the directory where we will save TLSA records already exist
	mkdir -p -m=0770 "$1" || outputMessage e004 "$1" & return $? 				# No, create it with owner/group rwx, something goes wrong error 9 & exit
	chown -R bind:bind "$1" || outputMessage e005 "$1" & return $? 				# set the owner & group to bind, something goes awry error 10 & exit
    fi
    if [ -d "$1" ]; then									# is $1 a directory, it should be
	if [[ ! -z $2 ]]; then									# do we have a second parameter
	    fileCount=$(( $(ls -1 "$1" | wc  -l) - 1 ))						# count the records in the directory - 1
	    [ $fileCount -lt 0 ] && fileCount=0							# count cannot be less than zero
	    newName=$(printf "%s.%04d" "$2" "$fileCount")					# create a filename format $2.nnnn
	    while [ -f "$1"/"$newName" ]; do							# does this file already exist, if so move on to the next possible new file
		oldName=$newName								# 
		(( fileCount++ ))								# up the count
		newName=$(printf "%s.%04d" "$2" "$fileCount")					# create new file name
	    done
	    echo "$newName" "$oldName"								# pass the names back to caller
	    return 0
	else
	    outputMessage e006; return $?							# oops, we didn't get $2, error 5  
	fi
    else
	outputMessage e007 "$1"; return $?							# oops, we don't have a directory, error 4
    fi
}

#                                          these two function need to have error handling added
getServiceData() {
    if [ ${#pseudoSRVrecords[@]} -le 0 ]; then							# are we using pseudo SRV records
	dig +short _"$1"._tcp."$2" SRV								# No, use dig to get SRV records 
    else
	echo 0 0 "${pseudoSRVrecords[$1.$2]}"							# yes, use the pseudo record data to emulate dig
    fi
}

getDomainData() {
    declare -a dnsSOAdata
    dnsSOAdata=( $(dig +noall +authority SOA "$1") )						# get the SOA data associated with the service (sub)domain 
    echo "${dnsSOAdata[0]%.}"									# pass back the doamin name
}

#                  THe following functions were "borrowed" from Viktor Dukhovni's tlsagen
#********************************************************************************************************************
setDigestGeneratorParms() {
    case "${1}" in
	0|pkix-[ct]a)	TLSA_Usage=0;;								#
	1|pkix-ee)	TLSA_Usage=1;;								#
	2|dane-[ct]a)	TLSA_Usage=2;;								#
	3|dane-ee)	TLSA_Usage=3;;								#
	*)		TLSA_Usage=3; outputMessage w008 "$1";;					# The usage parameter was not understood, set to default 3 and output msg
    esac
    case "${2}" in
	0|cert)		TLSA_Selector=0;;							#
	1|spki|pkey)	TLSA_Selector=1;;							#
	*)		TLSA_Selector=1; outputMessage w009 "$1";;				# The selector Parm was not understood, set to default 1 & output message
    esac
    case "${3}" in
	0|full)				TLSA_Type=0;;						# 
	1|sha2-256|sha256|sha-256)	TLSA_Type=1;;						#
	2|sha2-512|sha512|sha-512)	TLSA_Type=2;;						#
	*)				TLSA_Type=1; outputMessage w010 "$1";;			# the type param was not understood, set to default 1 & message
    esac
}

generateDigest() {
    extract() {
        case "$1" in
	    0) openssl x509 -in "$2" -outform DER;;						#
	    1) openssl x509 -in "$2" -noout -pubkey | openssl pkey -pubin -outform DER;;	# generate the DER data for the digest from the certificate
	esac
    }
    digest() {
	case "$1" in
	    0) cat;;										#
	    1) openssl dgst -sha256 -binary;;							# generate the certificate digest. length 256 or 512 bytes
	    2) openssl dgst -sha512 -binary;;							#
	esac
    }
    format() {
	od -vAn -tx1 | tr -d ' \012'								# convert the digest data to a hex string, removing any spaces & CRs
    }
    ( extract "$1" "$3" | digest "$2" | format )							# generate the digest 
    exit $(( PIPESTATUS[0] | PIPESTATUS[1] | PIPESTATUS[2] ))					# Check the previous step worked
}
#=====================================================================================================================================================================
#=====================================================================================================================================================================
#	Load "global" prefernces here, a we cannot use command line parameters when this is called 
#	from the certbots renew hook. They will have to go somewhere else, /etc/default/CertbotTLSAgen.cf 
#	for general parameters, and similar file placed in the ...../letsencrypt/live/$certname/hookname 
#	for certificate specifice data
[[ -f /etc/default/CertbotTLSAgen.cf ]] && . /etc/default/CertbotTLSAgen.cf

setupSystem											# normalize variable set defaults etc

if [ -f $installPath/CertbotTLSAgen."${LANG%%.*}".msgs ]; then					# Check to see if we have a message file for $LANG else use Canadian english 
    loadMessages "${LANG%%.*}"
else 
    loadMessages 'en_CA'
fi

setLineage "$1" || exit 									# As a command use $1, as a hook pick up RENEWED_LINEAGE. result certbotLineage
setDomains "$2" || exit 									# As a command use $2, as a hook pick up RENEWED_DOMAINS. result certbotDomains

#	Load "certificate specific" preferences here.
[[ -f "$certbotLineage"/CertbotTLSAgen.cf ]] && . "$certbotLineage"/CertbotTLSAgen.cf		# Load domain/certificate specific preferences here.


[[ ! -f "$installPath"/CertbotTLSAgen.DNSupdate."${updateAction}" ]] && updateAction='manual'	# check to see if the desired DNS update process exists

setupSystem											# normalize variable set defaults etc

#	Check the the out path and file exists, if not creat it the generate a new output files name return 
#	it plus the previous one if it exists. ** Only the new file is used at the moment **

outputFilenames=( $(setOutputFilenames $outputFilepath $outputFilenameBase)  ) || exit


#	Generate the TLSA key as a HEX string. As we are dealiing with a single cert do this once 

[[ "$TLSA_Record" = @(&nr) ]] && { outputMessage E997; exit; }
setDigestGeneratorParms "$TLSA_Usage" "$TLSA_Selector" "$TLSA_Type" || exit
[[ "$TLSA_Record" = @($pr) ]] && tlsaDigest=$( generateDigest  $TLSA_Selector $TLSA_Type "$certbotLineage"'/cert.pem' )



for domain in $( seq 0 $((${#certbotDomains[@]} -1 )) ); do					# For each (sub)domain listed in tghe input, check to see if it is a service domain that we might like to have a TLSA record for 
    targetURL=${certbotDomains[domain]%.}							# I am not sure whether the Cerbot list of (sub)domains has a trailing "."
    targetDomain=$( getDomainData "$targetURL" )						# get the domain for this (sub)domain 
        for service in $( seq 0 $((${#services[@]} -1 )) ); do					# Do this for each of the services that might us a TLSA record
	while read -r _ _ srv_port srv_host; do							# read the out put of a DIG for a SRV record 
	    if [[ ! -z "$srv_host" && ${srv_host%.} == $targetURL ]]; then			# if the host returned by dig = the Cerbot target output a TLSA record
		if [[ "$TLSA_Record" = @($pr) ]]; then
		    printf "_%d._tcp.%s %d IN TLSA %d %d %d %s\n" "$srv_port" "$srv_host" "$TLSA_TTL" "$TLSA_Usage" "$TLSA_Selector" "$TLSA_Type" "$tlsaDigest" >> "$outputFilepath/${outputFilenames[0]}"
		    outputMessage I016 "${services[$service]}" "$srv_port" "$srv_host"
		fi
	    fi
	done < <(getServiceData "${services[$service]}" "$targetDomain" )
    done
done

cmp -s "$outputFilepath${outputFilenames[0]}" "$outputFilepath${outputFilenames[1]}"

if [[ $? = 0 ]]; then
    rm "$outputFilepath${outputFilenames[0]}"
    outputMessage W014
else

    "$installPath"/CertbotTLSAgen.DNSupdate."${updateAction}" add "$outputFilepath" "${outputFilenames[0]}" 0 >&3 2>&3			# finished creating TLSA records, now update the DNS by adding records to DNS

    if [[ "$TLSA_AutoRemove" = @($pr) && ! -z "${outputFilenames[1]}" ]]; then 									# spawn this off to run after the remove delay has expired

	outputMessage i012 "$TLSA_RemoveDelay"

	("$installPath"/CertbotTLSAgen.DNSupdate."${updateAction}" delete "$outputFilepath" "${outputFilenames[1]}" "$TLSA_RemoveDelay") >&3 2>&3 < /dev/null & disown
    fi
fi
outputMessage i998 $(( ( 10#$(date +%N) - startTime) / 1000000 ))
exit 0
