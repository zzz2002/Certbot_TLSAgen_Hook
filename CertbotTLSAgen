#!/bin/bash
# -*- mode: bash; -*-
# Copyright (c) 2017 John L. Allen
# This program is free software: you can redistribute it and/or modify it under the terms of the 
# GNU General Public License as published by the Free Software Foundation, either version 3 of 
# the License, or (at your option) any later version.
# This program is distributed in the hope that it will be useful, but WITHOUT ANY WARRANTY; 
# without even the implied warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  
# *See the GNU General Public License for more details. You should have received a copy of the 
# GNU General Public License along with this program.  If not, see <http://www.gnu.org/licenses/>.
#
#Last modified:
#	2017-04-02
#	2017-04-07
#	2017-04-07 20:30
#=============
if [[ "${SHELL##*/}" != 'bash' || "${BASH_VERSINFO[0]:0:1}" -lt 4 ]]; then
    echo "error: script must run in bash version 4.0 or later"
    false
    exit
fi
shopt -s extglob								# start using bash features right after version check

startTime=10#$(date +%s%N)

positiveResponses='y|yes|t|tue'							#
negativeResponses='n|no|f|false'						#
defaultUpdateAction='manual'

declare -A messageText								# associative array containing information &  error messages
declare -a domainSoaData

#
# Variables derived either from the command line parameters or from the renew-hook environment variables.
#
certbotLineage=""								# path to the certbot generated cert ...(RENEWED_LINEAGE or $1)
declare -a certbotDomains							# An array into which RENEWED_DOMAINS or $2 Domains are split



########################################################################################################
################  the following variable can be overriddden/set using the config files #################
########################################################################################################
installPath="/root"								# where we are installed/stored

declare -a services=( smtp smtps submission imap sieve dav davical https )	# array of servics we want TLSA records for

updateAction="manual"								# what DNS update process(?) to use

CA_Record=y
CA_Usage=dane-ca								# dane-ca/ta usage 
CA_Selector=pkey								# dane-ca/ta selector 
CA_Type=sha-256									# dane-ca/ta type

EE_Record=y
EE_Usage=dane-ee								# dane-ee usage - always dan-ee
EE_Selector=pkey								# dane-ee selector 
EE_Type=sha-256									# dane-ee type

TLSA_TTL=1800									# TLSA DNS record TTL in seconds 
TLSA_RemoveDelay=3600								# the interval in seconds between adding new TLSA records and removing the old ones.
TLSA_AutoRemove=no

logOnly=no									# temp work around sysout + syslog
logFile="/var/log/A_tlsagen.log"						# logfile name & path

outputFilepath=									#if not specified, defaults to the cerbot lineage
########################################################################################################

declare -A pseudoSRVrecords							# associative array to be used when SRV records are not available

########################################################################################################
#
#	Try and reduce all the variations on yes and no, due to both language and user input to y or n 
#
normalizeResponse() {
    local x="$1"								# save the input value in x, if we don't understand it then just pass it back unchanged
    [[ ${1,,} = @($positiveResponses) ]] && x='y'				# if the input variable is one of the positive responses, set x to y
    [[ ${1,,} = @($negativeResponses) ]] && x='n'				# if the input variable is one of the negative responses, set x to n
    echo "$x"									# pass back the normalized value or the original
}

#
#	We can tell the user what to do, but they may not actually do it.
#	So we will try to make things look the way we expect them to be. May not work but ...
#
normalizeSystemVariables() {
    logOnly="$(normalizeResponse "$logOnly")"
    CA_Record="$(normalizeResponse "$CA_Record")"
    EE_Record="$(normalizeResponse "$EE_Record")"
    TLSA_AutoRemove="$(normalizeResponse "$TLSA_AutoRemove")"

    updateAction="${updateAction,,}"

    CA_Usage="${CA_Usage,,}"
    CA_Selector="${CA_Selector,,}"
    CA_Type="${CA_Type,,}"

    EE_Usage="${EE_Usage,,}"
    EE_Selector="${EE_Selector,,}"
    EE_Type="${EE_Type,,}"

    exec 3>> "$logFile"
}
#
#
#
outputMessage() {
    local errorCode												# local version of the error code
    local msgVars												# number of vaiables a message expects 
    local extraData												# additional data 
    local badCode												# variable to save additional data 
    local xitCode												# just what it says it is
    errorCode=${1^^}												# set the internal variable to the upper case $1
    [[ -z "$errorCode" || -z "${messageText[$errorCode]}" ]] && { badCode="$errorCode"; errorCode='E999'; }	# did we get passed an error code and do we have a message for it
														# no, set the oops code and save trhe actual code for diags 
    msgVars=$(( 10#${messageText[$errorCode]:0:1} ))								# yes,get the number of variables needed for this message
    extraData="${*:$(( msgVars + 2 ))}"										# save the extra data in a variable, stops the msg repeat
    extraData="${extraData%%\ *}"										# 
    [[ -n "$extraData" || -n "$badCode" ]] && extraData=' ** '"$badCode $extraData"				# add the seperator to front of this data
    printf -- "%s %s - %s ${messageText[$errorCode]:2} %s\n" "$(date "+%Y-%m-%d %H:%M:%S.%6N")" "${0##*/}" "$errorCode" "${@:2:$msgVars}" "$extraData" >&3
    [[ "$logOnly" = n ]] && printf  "%s - %s ${messageText[$errorCode]:2}  \n" "${0##*/}" "$errorCode" ${@:2:$msgVars} 2>&1

    case ${errorCode:0:1} in
	I|W) xitCode=0;;											# for info and warning messages return 0
	E|F) xitCode=1;;											# for error or fatal return 1
	*)   xitCode=3;;											# ooops, don't know what this means, exit 3
    esac
    return $xitCode
}
#
#	Load language dependent things like message, responses (y/n), email message texts ...
#	the first character of each line defines it purpose
#	I, W, E, F are messages:
#		I  Informational
#		W  Warning, we don't understand the settiong supplied, but there is a resonable default to use.
#		E  Error, something went wrong and we cannot continue
#	R Responses dependent on language
#		+  positive responses y/yes/t/true...   o/oui/v/vrai ...
#		-  negative responses n/no/f/false...   n/non/f/faux ...
#	M email message text(s)
#
#	the next three charcaters are dependent on the purpose, for messages it deines the message. 
#	the next column defines for messages the number of fields in the message.
#
loadLanguageDependent() {
    local aline
    local i
    local j
    while read -r aline; do	
	if [[ -n "$aline" ]]; then
	    j="${aline:0:1}"
	    aline="${aline%%\:\#\ \ *}"
	    case "${j^^}" in
		I|W|E)
		    i="${aline:0:4}"
		    messageText[${i^^}]=${aline:5}
		;;
		R)
		    [[ "${aline:1:1}" = '+' ]] && { positiveResponses="${aline:7}"; positiveResponses="${positiveResponses// /}"; }
		    [[ "${aline:1:1}" = '-' ]] && { negativeResponses="${aline:7}"; negativeResponses="${negativeResponses// /}"; }
		;;
		M)
		    #  future email message 
		;;
		*)	 #  any thing else is ignored for the moment
		;;
	    esac
	fi
    done < "$installPath"/CertbotTLSAgen."$1".data
}
#
# Check if either the Certbot environment variables or the command line parameters have been set, this may/will depend on how this script is invoked.
# N.B. The Command line parameter overides the environment variable should they both be present
#
# Has $1 or the environment variable RENEWED_LINEAGE been set.
#
setLineage() {
	certbotLineage=$RENEWED_LINEAGE
	[[ ! -z $1 ]] && certbotLineage=$1
	if [[ -z $certbotLineage ]]; then
	    outputMessage e001; return $?
	elif [[ ! -d $certbotLineage ]]; then
	    outputMessage e002; return $?
	fi
}
# Has $2 or the environment variable RENEWED_DOMAINS been set. If more than one domain is specified they are expected to be in the form of a space seperated list.
#
setDomains() {
	certbotDomains=( $RENEWED_DOMAINS )
	[[ ! -z $1 ]] && certbotDomains=( $1 )
	if [[ ${#certbotDomains[@]} -le 0 ]]; then 
	    outputMessage e003; return $?
	fi
}
#
#	these two function need to have error handling added
#
getServiceData() {
    if [ ${#pseudoSRVrecords[@]} -le 0 ]; then							# are we using pseudo SRV records
	dig +short _"$1"._tcp."$2" SRV								# No, use dig to get SRV records 
    else
	echo 0 0 "${pseudoSRVrecords[$1.$2]}"							# yes, use the pseudo record data to emulate dig
    fi
}

getDomainData() {
    dig +noall +authority SOA "$1"							# get the SOA data associated with the service (sub)domain 
}

#                  THe following code was "borrowed" from Viktor Dukhovni's tlsagen
#********************************************************************************************************************
#
generateDigest() {
#
# generate the DER data for the digest from the certificate
#
    extract() {
        case "$1" in
	    0) openssl x509 -in "$2" -outform DER;;
	    1) openssl x509 -in "$2" -noout -pubkey | openssl pkey -pubin -outform DER;;
	esac
    }
#
# generate the certificate digest. length 256 or 512 bytes
#
    digest() {
	case "$1" in
	    0) cat;;
	    1) openssl dgst -sha256 -binary;;
	    2) openssl dgst -sha512 -binary;;
	esac
    }
#
# convert the digest data to a hex string, removing any spaces & CRs
#
    format() {
	od -vAn -tx1 | tr -d ' \012' | tr [:lower:] [:upper:]
    }
#
# check and set the usage parameter. If was not understood, set to default 3 and output msg
#
    case "${1}" in
	0|pkix-[ct]a)	Usage=0;;
	1|pkix-ee)	Usage=1;;
	2|dane-[ct]a)	Usage=2;;
	3|dane-ee)	Usage=3;;
	*)		Usage=3; outputMessage w005 "$1";;
    esac
#
# Check and set the selector parameter. If not understood, set to default 1 & output message
#
    case "${2}" in
	0|cert)		Selector=0;;
	1|spki|pkey)	Selector=1;;
	*)		Selector=1; outputMessage w006 "$1";;
    esac
#
# Check and set the type parameter. If not understood, set to default 1 & message
#
    case "${3}" in
	0|full)				Type=0;;
	1|sha2-256|sha256|sha-256)	Type=1;;
	2|sha2-512|sha512|sha-512)	Type=2;;
	*)				Type=1; outputMessage w007 "$1";;
    esac
#
# generate the digest 
#
    echo "$Usage" "$Selector" "$Type" $( extract "$Selector" "$4" | digest "$Type" | format )
#
# Check the previous steps worked
#
    exit $(( PIPESTATUS[0] | PIPESTATUS[1] | PIPESTATUS[2] ))
}
#=====================================================================================================================================================================



#=====================================================================================================================================================================
#	My understanding is that we cannot use command line parameters when this is called as a certbots renew-hook.
#	They will have to go somewhere else, I chose to use /etc/default/CertbotTLSAgen.cf for general use preferences
#	And use a similar file placed in the ...../letsencrypt/live/$certname/hookname for certificate specifice data

#	Load global user preferences (/etc/default/CertbotTLSAgen.cf)
[[ -f /etc/default/CertbotTLSAgen.cf ]] && . /etc/default/CertbotTLSAgen.cf

#	Check to see if we have a file for $LANG (I use only the language code, I strip off the utf_8)
#	If so load the language specific file else load the Canadian english as the default

if [ -f $installPath/CertbotTLSAgen."${LANG%%.*}".data ]; then
    loadLanguageDependent "${LANG%%.*}"
    languageLoaded=y
else 
    loadLanguageDependent 'en_CA'
    languageLoaded=n
fi

#	normalize variable set after loading the global preferences & language etc
normalizeSystemVariables

#	output message about missing language dependent data module. Has to wait till now as we were still loading data.
[[ "$languageLoaded" = n ]] && outputMessage w009 "${LANG%%.*}" "en_CA"

setLineage "$1" || exit				# As a command use $1, as a hook pick up RENEWED_LINEAGE. result certbotLineage
setDomains "$2" || exit				# As a command use $2, as a hook pick up RENEWED_DOMAINS. result certbotDomains

#	Load "certificate specific" preferences here.
[[ -f "$certbotLineage"/CertbotTLSAgen.cf ]] && . "$certbotLineage"/CertbotTLSAgen.cf

#	normalize variable set after loading the certificate specific information
normalizeSystemVariables

#	check to see if the desired DNS update process exists.if not default to manual
[[ ! -f "$installPath"/CertbotTLSAgen.DNSupdate."${updateAction}" ]] && { updateAction="$defaultUpdateAction"; outputMessage w008 "$updateAction" "$defaultUpdateAction"; }

#	Generate the TLSA key as a HEX string. As we are dealiing with a single certificate do this once 
[[ "$EE_Record" = n && "$CA_Record" = n ]] && { outputMessage e004; exit; }
[[ "$CA_Record" = y ]] && dane_caDigest=$( generateDigest  "$CA_Usage" "$CA_Selector" "$CA_Type" "$certbotLineage"'/chain.pem' ) || exit
[[ "$EE_Record" = y ]] && dane_eeDigest=$( generateDigest  "$EE_Usage" "$EE_Selector" "$EE_Type" "$certbotLineage"'/cert.pem' ) || exit

# dane_caDigest="${dane_caDigest^^}"
# dane_eeDigest="${dane_eeDigest^^}"

#	setup where we are going to save the additions and deletions, Would normally be Certbot Lineage, but can be oerridden
[[ -z "$outputFilepath"  ]] && outputFilepath="$certbotLineage"
outputMessage i009 "$outputFilepath"

TLSA_delete_filename="$outputFilepath"'/TLSA_deletions'
[[ -s "$TLSA_delete_filename" ]] && rm "$TLSA_delete_filename"
TLSA_add_filename="$outputFilepath"'/TLSA_additions'
[[ -s "$TLSA_add_filename" ]] && rm "$TLSA_add_filename"

for domain in $( seq 0 $((${#certbotDomains[@]} -1 )) ); do					# For each (sub)domain listed in the input, check to see if it is a service domain that we might like to have a TLSA record for 
    duplicateCA=n
    duplicateEE=n
    targetURL=${certbotDomains[domain]%.}							# I am not sure whether the Cerbot list of (sub)domains has a trailing "."
    domainSoaData=( $(getDomainData "$targetURL") )						# get the SOA data associated with the service (sub)domain 
    for service in $( seq 0 $((${#services[@]} -1 )) ); do					# Do this for each of the services that might us a TLSA record
	while read -r _ _ srv_port srv_host; do							# read the out put of a DIG for a SRV record 
	    if [[ -n "$srv_host" && ${srv_host%.} == $targetURL ]]; then			# if the host returned by dig = the Cerbot target, then process it, else move on
		digTLSAData=$(dig +short +nosplit _"$srv_port"._tcp."$srv_host" TLSA)
		while read -r aLine; do
		    case "${aLine:0:1}" in							# get any tlsa records associated with this 
			2)
			    if [[ "$aLine" = $dane_caDigest ]]; then
				duplicateCA=y
			    else
				printf "_%d._tcp.%s TLSA %d %d %d %s\n" "$srv_port" "$srv_host" $aLine >> "$TLSA_delete_filename"
				outputMessage i010 "${services[$service]}" "$srv_port" "$srv_host"
			    fi
			;;
			3)
			    if [[ "$aLine" = $dane_eeDigest ]]; then
				duplicateEE=y
			    else
				printf "_%d._tcp.%s TLSA %d %d %d %s\n" "$srv_port" "$srv_host" $aLine >> "$TLSA_delete_filename"
				outputMessage i011 "${services[$service]}" "$srv_port" "$srv_host"
			    fi
			;;
			*)
			;;
		    esac
		done <<< "${digTLSAData^^}"
		if [[ "$CA_Record" = y && "$duplicateCA" = n ]]; then
		    printf "_%d._tcp.%s %d IN TLSA %d %d %d %s\n" "$srv_port" "$srv_host" "$TLSA_TTL" $dane_caDigest >> "$TLSA_add_filename"
		    outputMessage i012 "${services[$service]}" "$srv_port" "$srv_host"
		fi
		if [[ "$EE_Record" = y && "$duplicateEE" = n ]]; then
		    printf "_%d._tcp.%s %d IN TLSA %d %d %d %s\n" "$srv_port" "$srv_host" "$TLSA_TTL" $dane_eeDigest >> "$TLSA_add_filename"
		    outputMessage i013 "${services[$service]}" "$srv_port" "$srv_host"
		fi
	    fi
	done < <(getServiceData "${services[$service]}" "${domainSoaData[0]}" )
    done
done

#   finished creating TLSA update records, now update the DNS by adding records to DNS
#   and if there are any to delete spawn the update function  to run activating after the remove delay has expired

if [[ -s "$TLSA_add_filename" || -s "$TLSA_delete_filename" ]]; then
    [[ -s "$TLSA_add_filename" ]] && "$installPath"/CertbotTLSAgen.DNSupdate."${updateAction}" add "$TLSA_add_filename" >&3 2>&3
    if [[ "$TLSA_AutoRemove" = y && -s "$TLSA_delete_filename" ]]; then
	outputMessage i014 "$TLSA_RemoveDelay"
	("$installPath"/CertbotTLSAgen.DNSupdate."${updateAction}" delete "$TLSA_delete_filename" "$TLSA_RemoveDelay") >&3 2>&3 < /dev/null & disown
    fi
else
	outputMessage i015
fi

outputMessage i998 $(( ( 10#$(date +%s%N) - startTime ) / 1000000 ))
exit 0
