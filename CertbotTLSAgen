#!/usr/bin/env bash
# -*- mode: sh; -*-
# Copyright (c) 2017 John L. Allen
# This program is free software: you can redistribute it and/or modify it under the terms of the 
# GNU General Public License as published by the Free Software Foundation, either version 3 of 
# the License, or (at your option) any later version.
# This program is distributed in the hope that it will be useful, but WITHOUT ANY WARRANTY; 
# without even the implied warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  
# *See the GNU General Public License for more details. You should have received a copy of the 
# GNU General Public License along with this program.  If not, see <http://www.gnu.org/licenses/>.
#
#Last modified:
#	2017-04-02
#	2017-04-07
#	2017-04-07 20:30
#=============
if [[ "${SHELL##*/}" != 'bash' || "${BASH_VERSINFO[0]:0:1}" -lt 4 ]]; then
    echo "error: script must run in bash version 4.0 or later"
    false
    exit
fi
shopt -s extglob   # <--- start using bash features right after version check

startTime=10#$(date +%N)

installPath="/root"										# where we are installed/stored
updateAction="manual"										# what DNS update process(?) to use

												#** variables derived either from the command line parameters 
												#   or from the renew-hook environment variables
certbotLineage=""										# path to the certbot generated cert ...(RENEWED_LINEAGE or $1)
declare -a certbotDomains 									# array into which RENEWED_DOMAINS or $2 Domains are split

declare -a services=( smtp smtps submission imap sieve dav davical https )			# array of servics we want TLSA records for
declare -A pseudoSRVrecords									# associative array to be used when SRV records are not available

TLSA_TTL=1800											# TLSA DNS record TTL in seconds 
TLSA_RemoveDelay=2700										# the interval in seconds between adding new TLSA records and removing the old ones.
TLSA_AutoRemove=no

TLSA_Usage=dane-ee										# TLSA usage 
TLSA_Selector=pkey										# TLSA selector 
TLSA_Type=sha-256										# TLSA type

outputFilepath="/etc/bind/tlsa/example.com"							# where do you want to put the TLSA records, default values
outputFilenameBase="tlsa"									# base filename for the TLSA records - generated  as base_filename.sequence_number

logOnly=no											# temp work around sysout + syslog
logFile="/var/log/A_tlsagen.log"								# logfile name & path

declare -a outputFilenames									# array containing the file names for old and the new TLSA records 

declare -A messagetext										# associative array containing information &  error messages
    
normaliseVariables() {
    logOnly="${logOnly,,}"
    TLSA_AutoRemove="${TLSA_AutoRemove,,}"

    updateAction="${updateAction,,}"
    TLSA_Usage="${TLSA_Usage,,}"
    TLSA_Selector="${TLSA_Selector,,}"
    TLSA_Type="${TLSA_Type,,}"
    
}
outputMessage() {
    local i											# local version of the error code
    local pc											# number of vaiables a message expects 
    local ed
    local ex											# variable to save un-needed data 
    i=${1^^}											# set the internal variable to the upper case $1
    [[ -z "$i" || -z "${messagetext[$i]}" ]] && { ex="$i"; i='E999'; }				# did we get passed an error code and do we have a message for it
												# no, set the oops,code and save trhe actual code for diags 
    pc=${messagetext[$i]:0:1}									# yes,get the number of variables needed for this message
    ed="${@:$(( pc + 2 ))}"									# save the ectra data in a variable,stops the msg repeat
    [[ -n "$ed" || -n "$ex" ]] && ed=' - '"$ex $ed"						# add the seperator to fron of this data

    printf -- "$(date "+%Y-%m-%d %H:%M:%S.%6N") %s - %s ${messagetext[$i]:2}%s\n" "${0##*/}" "$i" "${@:2:$pc}" "$ed" >> "$logFile"
    [[ ${logOnly:0:1} = @(n|f|0) ]] && printf -- "%s - %s ${messagetext[$i]:2}  \n" "${0##*/}" "$i" "${@:2:$pc}" 1>&2

    case ${i:0:1} in
	I|W) return 0;;										# for info and warning messages return 0
	E|F) return 1;;										# for error or fatal return 1
	*)   exit 3;;										# ooops, don't know what this means, exit 3
    esac
}
loadMessages() {
    local aline
    while read -r aline; do
	    if [[ ${aline:0:1} != '#' ]]; then
		i=${aline:0:4}
		messagetext[$i]=${aline:5}
	    fi
    done < "$installPath"/CertbotTLSAgen."$1".msgs
}

setLineage() {
	certbotLineage=$RENEWED_LINEAGE								# Check if either the Certbot environment variables or the command line 
	[[ ! -z $1 ]] && certbotLineage=$1							# parameters have been set, this may/will depend on how this script is invoked.
	if [[ -z $certbotLineage ]]; then 							# N.B. The Command line parameter overides the environment variable 
	    return $(outputMessage e001)							# should they both be present
	elif [[ ! -d $certbotLineage ]]; then
	    return $(outputMessage e002)
	fi
}

setDomains() {
	certbotDomains=( $RENEWED_DOMAINS )							# Has $2 or the environment variable RENEWED_DOMAINS been set. If more than 
	[[ ! -z $1 ]] && certbotDomains=( $1 ) 							# one domain is specified they are expected to be in the form of a space 
	if [[ ${#certbotDomains[@]} -le 0 ]]; then 						# seperated list.
	    return $(outputMessage e003)
	fi
}

#	Check the outputFilepath - the location (directory) where files containing the generated TLSA records will be 
#	placed exists, if not mkdir. Check that the TLSA filename base has been set. The filename base is used to generate
#	filenames in the form of base.sequence

setOutputFilenames() {
    local oldName
    local newName
    local fileCount

    if [ ! -d "$1" ]; then 									# Does the directory where we will save TLSA records already exist
	mkdir -p -m=0770 "$1" || exit $(outputMessage e004 "$1")				# No, create it with owner/group rwx, something goes wrong error 9 & exit
	chown -R bind:bind "$1" || exit $(outputMessage e005 "$1")				# set the owner & group to bind, something goes awry error 10 & exit
    fi
    if [ -d "$1" ]; then									# is $1 a directory, it should be
	if [[ ! -z $2 ]]; then									# do we have a second parameter
	    fileCount=$(( $(ls -1 "$1" | wc  -l) - 1 ))						# count the records in the directory - 1
	    [ $fileCount -lt 0 ] && fileCount=0							# count cannot be less than zero
	    newName=$(printf "%s.%04d" "$2" "$fileCount")					# create a filename format $2.nnnn
	    while [ -f "$1"/"$newName" ]; do							# does this file already exist, if so move on to the next possible new file
		oldName=$newName								# 
		(( fileCount++ ))								# up the count
		newName=$(printf "%s.%04d" "$2" "$fileCount")					# create new file name
	    done
	    [[ -z $oldName ]] && oldName=$newName						#
	    echo "$newName" "$oldName"								# pass the names back to caller
	    return 0
	else
	    return $(outputMessage e006)							# oops, we didn't get $2, error 5  
	fi
    else
	return $(outputMessage e007 "$1")							# oops, we don't have a directory, error 4
	exit
    fi
}

#                                          these two function need to have error handling added
getServiceData() {
    if [ ${#pseudoSRVrecords[@]} -le 0 ]; then							# are we using pseudo SRV records
	dig +short _"$1"._tcp."$2" SRV								# No, use dig to get SRV records 
    else
	echo 0 0 "${pseudoSRVrecords[$1.$2]}"							# yes, use the pseudo record data to emulate dig
    fi
}

getDomainData() {
    declare -a dnsSOAdata
    dnsSOAdata=( $(dig +noall +authority SOA "$1") )						# get the SOA data associated with the service (sub)domain 
    echo "${dnsSOAdata[0]%.}"									# pass back the doamin name
}

#                  THe following functions were "borrowed" from Viktor Dukhovni's tlsagen
#********************************************************************************************************************
setDigestGeneratorParms() {
    case "${1}" in
	0|pkix-[ct]a)	TLSA_Usage=0;;								#
	1|pkix-ee)	TLSA_Usage=1;;								#
	2|dane-[ct]a)	TLSA_Usage=2;;								#
	3|dane-ee)	TLSA_Usage=3;;								#
	*)		TLSA_Usage=3; outputMessage w008 "$1";;					# The usage parameter was not understood, set to default 3 and output msg
    esac
    case "${2}" in
	0|cert)		TLSA_Selector=0;;							#
	1|spki|pkey)	TLSA_Selector=1;;							#
	*)		TLSA_Selector=1; outputMessage w009 "$1";;				# The selector Parm was not understood, set to default 1 & output message
    esac
    case "${3}" in
	0|full)				TLSA_Type=0;;						# 
	1|sha2-256|sha256|sha-256)	TLSA_Type=1;;						#
	2|sha2-512|sha512|sha-512)	TLSA_Type=2;;						#
	*)				TLSA_Type=1; outputMessage w010 "$1";;			# the type param was not understood, set to default 1 & message
    esac
}

GenerateCertificateDigest() {
    extract() {
        case "$1" in
	    0) openssl x509 -in "$2" -outform DER;;						#
	    1) openssl x509 -in "$2" -noout -pubkey | openssl pkey -pubin -outform DER;;	# generate the DER data for the digest from the certificate
	esac
    }
    digest() {
	case "$1" in
	    0) cat;;										#
	    1) openssl dgst -sha256 -binary;;							# generate the certificate digest. length 256 or 512 bytes
	    2) openssl dgst -sha512 -binary;;							#
	esac
    }
    format() {
	od -vAn -tx1 | tr -d ' \012'								# convert the digest data to a hex string, removing any spaces & CRs
    }
    ( extract $1 $3 | digest $2 | format )							# generate the digest 
    exit $(( PIPESTATUS[0] | PIPESTATUS[1] | PIPESTATUS[2] ))					# Check the previous step worked
}

#	Load "global" prefernces here, a we cannot use command line parameters when this is called 
#	from the certbots renew hook. They will have to go somewhere else, /etc/default/CertbotTLSAgen.cf 
#	for general parameters, and similar file placed in the ...../letsencrypt/live/$certname/hookname 
#	for certificate specifice data
[[ -f /etc/default/CertbotTLSAgen.cf ]] && . /etc/default/CertbotTLSAgen.cf

if [ -f $installPath/CertbotTLSAgen.${LANG%%.*}.msgs ]; then					# Check to see if we have a message file for $LANG else use Canadian english 
    loadMessages "${LANG%%.*}"
else 
    loadMessages 'en_CA'
fi

setLineage "$1" || exit 									# As a command use $1, as a hook pick up RENEWED_LINEAGE. result certbotLineage
setDomains "$2" || exit 									# As a command use $2, as a hook pick up RENEWED_DOMAINS. result certbotDomains

#	Load "certificate specific" preferences here.
[[ -f "$certbotLineage"/CertbotTLSAgen.cf ]] && . "$certbotLineage"/CertbotTLSAgen.cf		# Load domain/certificate specific preferences here.

[[ ! -f "$installPath"/CertbotTLSAgen.DNSupdate."${updateAction}" ]] && updateAction='manual'	# check to see if the desired DNS update process exists

normaliseVariables										# ensure that variables that we expect to be lower case are lower case

#	Check the the out path and file exists, if not creat it the generate a new output files name return 
#	it plus the previous one if it exists. ** Only the new file is used at the moment **

outputFilenames=( $(setOutputFilenames $outputFilepath $outputFilenameBase)  ) || exit


#	Generate the TLSA key as a HEX string. As we are dealiing with a single cert do this once 

setDigestGeneratorParms "$TLSA_Usage" "$TLSA_Selector" "$TLSA_Type" || exit
certificateDigest=$( GenerateCertificateDigest  $TLSA_Selector $TLSA_Type "$certbotLineage"/cert.pem ) || exit

#	For each (sub)domain listed, check to see if it is a service domain that we might like to have a TLSA record for 

for domain in $( seq 0 $((${#certbotDomains[@]} -1 )) ); do
    targetURL=${certbotDomains[domain]%.}							# I am not sure whether the Cerbot list of (sub)domains has a trailing "."
    targetDomain=$( getDomainData "$targetURL" )						# get the domain for this (sub)domain 
        for service in $( seq 0 $((${#services[@]} -1 )) ); do					# Do this for each of the services that might us a TLSA record
	while read -r _ _ srv_port srv_host; do							# read the out put of a DIG for a SRV record 
	    if [[ ! -z "$srv_host" && ${srv_host%.} == "$targetURL" ]]; then			# if the host returned by dig = the Cerbot target output a TLSA record

		printf "_%d._tcp.%s %d IN TLSA %d %d %d %s\n" "$srv_port" "$srv_host" "$TLSA_TTL" "$TLSA_Usage" "$TLSA_Selector" "$TLSA_Type" "$certificateDigest" >> "$outputFilepath/${outputFilenames[0]}"

		outputMessage i997 "${services[$service]}" "$srv_port" "$srv_host"
	    fi
	done < <(getServiceData "${services[$service]}" "$targetDomain" )
    done
done

# 				finished creating TLSA records, now update the DNS -  add records to DNS

"$installPath"/CertbotTLSAgen.DNSupdate."${updateAction}" add "$outputFilepath" "${outputFilenames[0]}" 0 >> "$logFile" 2>&1

#				spawn this off to run after the remove delay has expired

[[ "${TLSA_AutoRemove:0:1}" = @(y|t|1) && "${outputFilenames[0]}" != "${outputFilenames[1]}" ]] && 
    ("$installPath"/CertbotTLSAgen.DNSupdate."${updateAction}" delete "$outputFilepath" "${outputFilenames[1]}" "$TLSA_RemoveDelay") >> "$logFile" 2>&1 < /dev/null & disown

outputMessage i998 $(( ( 10#$(date +%N) - startTime) / 1000000 ))
exit 0

