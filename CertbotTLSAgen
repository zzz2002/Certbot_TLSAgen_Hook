#!/bin/bash -x
# -*- mode: bash; -*-
# Copyright (c) 2017 John L. Allen
# This program is free software: you can redistribute it and/or modify it under the terms of the 
# GNU General Public License as published by the Free Software Foundation, either version 3 of 
# the License, or (at your option) any later version.
# This program is distributed in the hope that it will be useful, but WITHOUT ANY WARRANTY; 
# without even the implied warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  
# *See the GNU General Public License for more details. You should have received a copy of the 
# GNU General Public License along with this program.  If not, see <http://www.gnu.org/licenses/>.
#
#Last modified:
#	2017-04-02
#	2017-04-07
#	2017-04-07 20:30
#=============
if [[ "${SHELL##*/}" != 'bash' || "${BASH_VERSINFO[0]:0:1}" -lt 4 ]]; then
    echo "error: script must run in bash version 4.0 or later"
    false
    exit
fi
shopt -s extglob   										# <--- start using bash features right after version check

startTime=10#$(date +%N)

positiveResponses=''
negativeResponses=''
 
installPath="/root"										# where we are installed/stored
updateAction="manual"										# what DNS update process(?) to use

												#** variables derived either from the command line parameters 
												#   or from the renew-hook environment variables
certbotLineage=""										# path to the certbot generated cert ...(RENEWED_LINEAGE or $1)
declare -a certbotDomains 									# array into which RENEWED_DOMAINS or $2 Domains are split

declare -a services=( smtp smtps submission imap sieve dav davical https )			# array of servics we want TLSA records for
declare -A pseudoSRVrecords									# associative array to be used when SRV records are not available

CA_Record=y
CA_Usage=dane-ca										# dane-ca/ta usage 
CA_Selector=pkey										# dane-ca/ta selector 
CA_Type=sha-256											# dane-ca/ta type


EE_Record=y
EE_Usage=dane-ee										# dane-ee usage - always dan-ee
EE_Selector=pkey										# dane-ee selector 
EE_Type=sha-256											# dane-ee type

TLSA_TTL=1800											# TLSA DNS record TTL in seconds 
TLSA_RemoveDelay=2700										# the interval in seconds between adding new TLSA records and removing the old ones.
TLSA_AutoRemove=no

outputFilepath="/etc/bind/tlsa/example.com"							# where do you want to put the TLSA records, default values
outputFilenameBase="tlsa"									# base filename for the TLSA records - generated  as base_filename.sequence_number

logOnly=no											# temp work around sysout + syslog
logFile="/var/log/A_tlsagen.log"								# logfile name & path

declare -a outputFilenames									# array containing the file names for old and the new TLSA records 

declare -A messageText										# associative array containing information &  error messages

############################################################################################################
#
#	Try and reduce all the variations on yes and no, due to both language and user input to y or n 
#
normalizeResponse() {
    local x="$1"										# save the input value in x, if we don't understand it then just pass it back unchanged
    [[ ${1,,} = @($positiveResponses) ]] && x='y'						# if the input variable is one of the positive responses, set x to y
    [[ ${1,,} = @($negativeResponses) ]] && x='n'						# if the input variable is one of the negative responses, set x to n
    echo "$x"											# pass back the normalized value or the original
}

#
#	We can tell the user what to do, but they may not actually do it.
#	So we will try to make things look the way we expect them to be. May not work but ...
#
normalizeSystemVariables() {
    logOnly="$(normalizeResponse "$logOnly")"
    EE_Record="$(normalizeResponse "$EE_Record")"
    TLSA_AutoRemove="$(normalizeResponse "$TLSA_AutoRemove")"

    updateAction="${updateAction,,}"
    EE_Usage="${EE_Usage,,}"
    EE_Selector="${EE_Selector,,}"
    EE_Type="${EE_Type,,}"

    exec 3>> "$logFile"
}
#
#
#
outputMessage() {
    local errorCode												# local version of the error code
    local msgVars												# number of vaiables a message expects 
    local extraData												# additional data 
    local badCode												# variable to save additional data 
    local xitCode												# just what it says it is
    errorCode=${1^^}												# set the internal variable to the upper case $1
    [[ -z "$errorCode" || -z "${messageText[$errorCode]}" ]] && { badCode="$errorCode"; errorCode='E999'; }	# did we get passed an error code and do we have a message for it
														# no, set the oops code and save trhe actual code for diags 
    msgVars=$(( 10#${messageText[$errorCode]:0:1} ))								# yes,get the number of variables needed for this message
    extraData="${*:$(( msgVars + 2 ))}"										# save the extra data in a variable, stops the msg repeat
    extraData="${extraData%%\ *}"										# 
    [[ -n "$extraData" || -n "$badCode" ]] && extraData=' ** '"$badCode $extraData"				# add the seperator to front of this data
    printf -- "%s %s - %s ${messageText[$errorCode]:2} %s\n" "$(date "+%Y-%m-%d %H:%M:%S.%6N")" "${0##*/}" "$errorCode" "${@:2:$msgVars}" "$extraData" >&3
    [[ "$logOnly" = n ]] && printf  "%s - %s ${messageText[$errorCode]:2}  \n" "${0##*/}" "$errorCode" ${@:2:$msgVars} 2>&1

    case ${errorCode:0:1} in
	I|W) xitCode=0;;											# for info and warning messages return 0
	E|F) xitCode=1;;											# for error or fatal return 1
	*)   xitCode=3;;											# ooops, don't know what this means, exit 3
    esac
    return $xitCode
}
#
#	Load language dependent things like message, responses (y/n), email message texts ...
#	the first character of each line defines it purpose
#	I, W, E, F are messages:
#		I  Informational
#		W  Warning, we don't understand the settiong supplied, but there is a resonable default to use.
#		E  Error, something went wrong and we cannot continue
#		F  Fatal, not sure that this is needed (MAY BE DROPPED)
#	R Responses dependent on language
#		+  positive responses y/yes/t/true...   o/oui/v/vrai ...
#		-  negative responses n/no/f/false...   n/non/f/faux ...
#	M email message text(s)
#
#	the next three charcaters are dependent on the purpose, for messages it deines the message. 
#	the next column defines for messages the number of fields in the message.
#
loadLanguageDependent() {
    local aline
    local i
    local j
    while read -r aline; do
	    if [[ -n "$aline" ]]; then
		j="${aline:0:1}"
		aline="${aline%%\:\#\ \ *}"
		case "${j^^}" in
		    I|W|E|F)
			i="${aline:0:4}"
			messageText[${i^^}]=${aline:5}
			;;
		    R)
			[[ "${aline:1:1}" = '+' ]] && { positiveResponses="${aline:7}"; positiveResponses="${positiveResponses// /}"; }
			[[ "${aline:1:1}" = '-' ]] && { negativeResponses="${aline:7}"; negativeResponses="${negativeResponses// /}"; }
			;;
		    M)
			#  future email message 
		    ;;
		    *)
		        #  any thing else is ignored for the moment
		    ;;
		esac
	    fi
    done < "$installPath"/CertbotTLSAgen."$1".msgs
}

setLineage() {
	certbotLineage=$RENEWED_LINEAGE								# Check if either the Certbot environment variables or the command line 
	[[ ! -z $1 ]] && certbotLineage=$1							# parameters have been set, this may/will depend on how this script is invoked.
	if [[ -z $certbotLineage ]]; then 							# N.B. The Command line parameter overides the environment variable 
	    outputMessage e001;  return $?							# should they both be present
	elif [[ ! -d $certbotLineage ]]; then
	    outputMessage e002; return $?
	fi
}

setDomains() {
	certbotDomains=( $RENEWED_DOMAINS )							# Has $2 or the environment variable RENEWED_DOMAINS been set. If more than 
	[[ ! -z $1 ]] && certbotDomains=( $1 ) 							# one domain is specified they are expected to be in the form of a space 
	if [[ ${#certbotDomains[@]} -le 0 ]]; then 						# seperated list.
	    outputMessage e003; return $?
	fi
}

#	Check the outputFilepath - the location (directory) where files containing the generated TLSA records will be 
#	placed exists, if not mkdir. Check that the TLSA filename base has been set. The filename base is used to generate
#	filenames in the form of base.sequence

setOutputFilenames() {
    local oldName
    local newName
    local fileCount

    if [ ! -d "$1" ]; then 									# Does the directory where we will save TLSA records already exist
	mkdir -p -m=0770 "$1" || outputMessage e004 "$1" & return $? 				# No, create it with owner/group rwx, something goes wrong error 9 & exit
	chown -R bind:bind "$1" || outputMessage e005 "$1" & return $? 				# set the owner & group to bind, something goes awry error 10 & exit
    fi
    if [ -d "$1" ]; then									# is $1 a directory, it should be
	if [[ ! -z $2 ]]; then									# do we have a second parameter
	    fileCount=$(( $(ls -1 "$1" | wc  -l) - 1 ))						# count the records in the directory - 1
	    [ $fileCount -lt 0 ] && fileCount=0							# count cannot be less than zero
	    newName=$(printf "%s.%04d" "$2" "$fileCount")					# create a filename format $2.nnnn
	    while [ -f "$1"/"$newName" ]; do							# does this file already exist, if so move on to the next possible new file
		oldName=$newName								# 
		(( fileCount++ ))								# up the count
		newName=$(printf "%s.%04d" "$2" "$fileCount")					# create new file name
	    done
	    echo "$newName" "$oldName"								# pass the names back to caller
	    return 0
	else
	    outputMessage e006; return $?							# oops, we didn't get $2, error 5  
	fi
    else
	outputMessage e007 "$1"; return $?							# oops, we don't have a directory, error 4
    fi
}
#
#	these two function need to have error handling added
#
getServiceData() {
    if [ ${#pseudoSRVrecords[@]} -le 0 ]; then							# are we using pseudo SRV records
	dig +short _"$1"._tcp."$2" SRV								# No, use dig to get SRV records 
    else
	echo 0 0 "${pseudoSRVrecords[$1.$2]}"							# yes, use the pseudo record data to emulate dig
    fi
}

getDomainData() {
    declare -a dnsSOAdata
    dnsSOAdata=( $(dig +noall +authority SOA "$1") )						# get the SOA data associated with the service (sub)domain 
    echo "${dnsSOAdata[0]%.}"									# pass back the doamin name
}

#                  THe following code was "borrowed" from Viktor Dukhovni's tlsagen
#********************************************************************************************************************
#
generateDigest() {
    extract() {
        case "$1" in
	    0) openssl x509 -in "$2" -outform DER;;						#
	    1) openssl x509 -in "$2" -noout -pubkey | openssl pkey -pubin -outform DER;;	# generate the DER data for the digest from the certificate
	esac
    }
    digest() {
	case "$1" in
	    0) cat;;										#
	    1) openssl dgst -sha256 -binary;;							# generate the certificate digest. length 256 or 512 bytes
	    2) openssl dgst -sha512 -binary;;							#
	esac
    }
    format() {
	od -vAn -tx1 | tr -d ' \012'								# convert the digest data to a hex string, removing any spaces & CRs
    }

    case "${1}" in
	0|pkix-[ct]a)	Usage=0;;								#
	1|pkix-ee)	Usage=1;;								#
	2|dane-[ct]a)	Usage=2;;								#
	3|dane-ee)	Usage=3;;								#
	*)		Usage=3; outputMessage w008 "$1";;					# The usage parameter was not understood, set to default 3 and output msg
    esac
    case "${2}" in
	0|cert)		Selector=0;;								#
	1|spki|pkey)	Selector=1;;								#
	*)		Selector=1; outputMessage w009 "$1";;					# The selector Parm was not understood, set to default 1 & output message
    esac
    case "${3}" in
	0|full)				Type=0;;						# 
	1|sha2-256|sha256|sha-256)	Type=1;;						#
	2|sha2-512|sha512|sha-512)	Type=2;;						#
	*)				Type=1; outputMessage w010 "$1";;			# the type param was not understood, set to default 1 & message
    esac

    echo "$Usage" "$Selector" "$Type" $( extract "$Selector" "$4" | digest "$Type" | format )	# generate the digest 
    exit $(( PIPESTATUS[0] | PIPESTATUS[1] | PIPESTATUS[2] ))					# Check the previous step worked
}
#=====================================================================================================================================================================



#=====================================================================================================================================================================
#	My understanding is that we cannot use command line parameters when this is called as a certbots renew-hook.
#	They will have to go somewhere else, I chose to use /etc/default/CertbotTLSAgen.cf for general use preferences
#	And use a similar file placed in the ...../letsencrypt/live/$certname/hookname for certificate specifice data
#
[[ -f /etc/default/CertbotTLSAgen.cf ]] && . /etc/default/CertbotTLSAgen.cf			# Load global user preferences (/etc/default/CertbotTLSAgen.cf)

if [ -f $installPath/CertbotTLSAgen."${LANG%%.*}".msgs ]; then					# Check to see if we have a file for $LANG, I use only the language code, I strip off ther utf_8  
    loadLanguageDependent "${LANG%%.*}"								# if so load the language specific file
else 
    loadLanguageDependent 'en_CA'								# else load the Canadian english as the default
fi

normalizeSystemVariables									# normalize variable set after loading the global preferences & language etc

setLineage "$1" || exit 									# As a command use $1, as a hook pick up RENEWED_LINEAGE. result certbotLineage
setDomains "$2" || exit 									# As a command use $2, as a hook pick up RENEWED_DOMAINS. result certbotDomains

#	Load "certificate specific" preferences here.
[[ -f "$certbotLineage"/CertbotTLSAgen.cf ]] && . "$certbotLineage"/CertbotTLSAgen.cf		# Load domain/certificate specific preferences here.

normalizeSystemVariables									# normalize variable set after loading the certificate specific information

[[ ! -f "$installPath"/CertbotTLSAgen.DNSupdate."${updateAction}" ]] && updateAction='manual'	# check to see if the desired DNS update process exists

#	Check the the out path and file exists, if not create it the generate a new output files name return 
#	it plus the previous one if it exists. ** Only the new file is used at the moment **

outputFilenames=( $(setOutputFilenames $outputFilepath $outputFilenameBase)  ) || exit


#	Generate the TLSA key as a HEX string. As we are dealiing with a single cert do this once 

[[ "$EE_Record" = n ]] && { outputMessage E997; exit; }
[[ "$EE_Record" = y ]] && dane_eeDigest=$( generateDigest  "$EE_Usage" "$EE_Selector" "$EE_Type" "$certbotLineage"'/cert.pem' ) || exit



for domain in $( seq 0 $((${#certbotDomains[@]} -1 )) ); do					# For each (sub)domain listed in tghe input, check to see if it is a service domain that we might like to have a TLSA record for 
    targetURL=${certbotDomains[domain]%.}							# I am not sure whether the Cerbot list of (sub)domains has a trailing "."
    targetDomain=$( getDomainData "$targetURL" )						# get the domain for this (sub)domain 
        for service in $( seq 0 $((${#services[@]} -1 )) ); do					# Do this for each of the services that might us a TLSA record
	while read -r _ _ srv_port srv_host; do							# read the out put of a DIG for a SRV record 
	    if [[ -n "$srv_host" && ${srv_host%.} == $targetURL ]]; then			# if the host returned by dig = the Cerbot target, then process it, else move on
#		get any tlsa records associated with this 
#		split the dig output into 
		if [[ "$EE_Record" = y ]]; then
#		    printf "_%d._tcp.%s %d IN TLSA %d %d %d %s\n" "$srv_port" "$srv_host" "$TLSA_TTL" "$EE_Usage" "$EE_Selector" "$EE_Type" "$dane_eeDigest" >> "$outputFilepath/${outputFilenames[0]}"
		    printf "_%d._tcp.%s %d IN TLSA %d %d %d %s\n" "$srv_port" "$srv_host" "$TLSA_TTL" $dane_eeDigest >> "$outputFilepath/${outputFilenames[0]}"
		    outputMessage I016 "${services[$service]}" "$srv_port" "$srv_host"
		fi
	    fi
	done < <(getServiceData "${services[$service]}" "$targetDomain" )
    done
done

cmp -s "$outputFilepath${outputFilenames[0]}" "$outputFilepath${outputFilenames[1]}"

if [[ $? = 0 ]]; then
    rm "$outputFilepath${outputFilenames[0]}"
    outputMessage W014
else

    "$installPath"/CertbotTLSAgen.DNSupdate."${updateAction}" add "$outputFilepath" "${outputFilenames[0]}" 0 >&3 2>&3			# finished creating TLSA records, now update the DNS by adding records to DNS

    if [[ "$TLSA_AutoRemove" = y && ! -z "${outputFilenames[1]}" ]]; then 									# spawn this off to run after the remove delay has expired

	outputMessage i012 "$TLSA_RemoveDelay"

	("$installPath"/CertbotTLSAgen.DNSupdate."${updateAction}" delete "$outputFilepath" "${outputFilenames[1]}" "$TLSA_RemoveDelay") >&3 2>&3 < /dev/null & disown
    fi
fi
outputMessage i998 $(( ( 10#$(date +%N) - startTime) / 1000000 ))
exit 0
